# -*- coding: utf-8 -*-
"""Movie Recommendations (based on popularity)
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/16Kcayk4pqgDGN1DaVwTjqZL88-o5spHJ
#Movie Recommender
**The Dataset**
The movies dataset contains metadata for 45,000 movies released on or before July 2017 and listed in the [MovieLens](https://movielens.org) database. Features include genre, title, budget, revenue, release dates, languages, production countries and companies, countries, [TMDB](https://www.themoviedb.org) vote counts and vote averages, and other details. Below are the features information:
**Attribute Information:**
    adult: Indicates if the movie is X-Rated or Adult.
    belongs_to_collection: A stringified dictionary that gives information on the movie series the particular film belongs to.
    budget: The budget of the movie in dollars.
    genres: A stringified list of dictionaries that list out all the genres associated with the movie.
    homepage: The Official Homepage of the move.
    id: The ID of the movie.
    imdb_id: The IMDB ID of the movie.
    original_language: The language in which the movie was originally shot in.
    original_title: The original title of the movie.
    overview: A brief blurb of the movie.
    popularity: The Popularity Score assigned by TMDB.
    poster_path: The URL of the poster image.
    production_companies: A stringified list of production companies involved with the making of the movie.
    production_countries: A stringified list of countries where the movie was shot/produced in.
    release_date: Theatrical Release Date of the movie.
    revenue: The total revenue of the movie in dollars.
    runtime: The runtime of the movie in minutes.
    spoken_languages: A stringified list of spoken languages in the film.
    status: The status of the movie (Released, To Be Released, Announced, etc.)
    tagline: The tagline of the movie.
    title: The Official Title of the movie.
    video: Indicates if there is a video present of the movie with TMDB.
    vote_average: The average rating of the movie.
    vote_count: The number of votes by users, as counted by TMDB.
<br>
**Problem Statement**
- Need to find out the most important features in the dataset to build a recommender system to suggest top movies for new subscribers.
- As new subscribers do not have a watch history, identify and suggest top rated movies which a new user is likely to appreciate and as a result stay connected to the streaming platform.
**Acknowledgement:** This dataset is an ensemble created by Rounak Banik using the data collected from TMDB and GroupLens.
**Dataset Source:** https://www.kaggle.com/rounakbanik/the-movies-dataset
**Dataset Link:** https://drive.google.com/uc?id=1rPR-P45M2UWsbXc8vpyCzWcQAYUfgVJX
"""

#importing the requried modules
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

#reading the dataset
url = "https://drive.google.com/uc?id=1rPR-P45M2UWsbXc8vpyCzWcQAYUfgVJX"
movies_df = pd.read_csv(url)

#new dataframe with only reqired columns
mov_subset_df = movies_df[['genres', 'id', 'popularity', 'title', 'vote_average', 'vote_count']]

#Data Cleaning
mov_subset_df = mov_subset_df.drop_duplicates(subset = ['id']) #dropping duplicates rows in id column
mov_subset_df.dropna(inplace = True) # dropping null vales from the new df
mov_subset_df['id'] = mov_subset_df['id'].astype('int') # converting id to int
mov_subset_df['popularity'] = mov_subset_df['popularity'].astype('float') #converting popularity to int

#using lambda function & literal_eval() to obtain a list of genres.
from ast import literal_eval
mov_subset_df['genres'] = mov_subset_df['genres'].apply(lambda x: [i['name'] for i in literal_eval(x)])

#exploding the dataframe
#explode genres column and give new index to every row.
genres_subset_df = mov_subset_df.explode('genres', ignore_index = True)

#recommendations based on popularity
#top 20 movies as per popularity of the movie
top_20_popular = mov_subset_df.sort_values(by = 'popularity', ascending = False).head(20)
top_20_popular

#plotting top 20 popular movies
plt.figure(figsize = (12, 6))
sns.barplot(x='popularity', y= 'title', data = top_20_popular)
plt.title("Top 20 popular movies")
plt.show()

#percentage of null values in genres_subset_df
genres_subset_df.isna().sum()*100/genres_subset_df.shape[0]

#dropping movies with null genres
genres_subset_df.dropna(inplace=True)
genres_subset_df.isna().sum()*100/genres_subset_df.shape[0]

#count of movies in each genre
genre_count = genres_subset_df['genres'].value_counts()
genre_count

#barplot w/ number of movies in each genre
sns.barplot(x=genre_count.values, y=genre_count.index)
plt.show()

#pivot table
#DataFrame w/ genres, popularity, vote_average and vote_count
parameters_df = genres_subset_df[['genres', 'popularity', 'vote_average', 'vote_count']]
genre_table = pd.pivot_table(parameters_df, index =['genres']).reset_index()
genre_table

# avg popularity score in descending order vs genres
sns.barplot(data=genre_table.sort_values(by="popularity", ascending=False), x='popularity', y='genres')
plt.show()

#plotting average vote_count arranged in descending order vs genres
sns.barplot(data=genre_table.sort_values(by="vote_count", ascending=False), x='vote_count', y='genres')
plt.show()

#plotting mean vote_average arranged in descending order vs genres
sns.barplot(data=genre_table.sort_values(by="vote_average", ascending=False), x='vote_average'
, y='genres')
plt.show()

#recommending top 20 movies as per average rating of the movie
top_20  = mov_subset_df.sort_values(by="vote_average", ascending=False).head(20)
top_20

#mean of vote_average
c = mov_subset_df['vote_average'].mean()
c

#minnumber of votes for a movie in order to qualify it for recommendation
m = mov_subset_df['vote_count'].quantile(0.9)
m

#DataFrame of movies having vote_count more than minimum number of votes
qualified_movies_df = mov_subset_df.copy().loc[mov_subset_df['vote_count']>= m]
qualified_movies_df.head()

#claculating weighted avg
def weighted_rating(df):
  v = df['vote_count']
  r = df['vote_average']
  w = (r*v + c*m)/(v+m)
  return w

#appending a column for the weighted rating of the movies in the DataFrame
qualified_movies_df['weighted_rating'] = qualified_movies_df.apply(weighted_rating, axis=1)
qualified_movies_df.head()

#top 25 movies.
qualified_movies_df.sort_values(by='weighted_rating', ascending=False, inplace=True)
qualified_movies_df.head()

#genre based DataFrame for qualified movies
genres_df = qualified_movies_df.explode('genres', ignore_index=True)
genres_df.head()

#genre based recommender
def genre_recommender(fav_genre):
  recommended_df = genres_df[genres_df['genres'] == fav_genre]
  return(recommended_df.head(25))

#checking recommendation for Thriller movies
genre_recommender('Thriller')

#checking eecommendation for Horror movies
genre_recommender("Horror")

#checking recommendation for Drama movies
genre_recommender("Drama")